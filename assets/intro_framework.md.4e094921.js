import{_ as a,a as e}from"./chunks/rabbitMQ_server.a04d9463.js";import{_ as r,c as o,o as t,N as s}from"./chunks/framework.ea74715b.js";const p="/assets/plugin-in.481b3373.png",i="/assets/project.c3006eca.png",q=JSON.parse('{"title":"架构","description":"","frontmatter":{},"headers":[],"relativePath":"intro/framework.md"}'),n={name:"intro/framework.md"},c=s('<h1 id="架构" tabindex="-1">架构 <a class="header-anchor" href="#架构" aria-label="Permalink to &quot;架构&quot;">​</a></h1><h2 id="架构-1" tabindex="-1">架构 <a class="header-anchor" href="#架构-1" aria-label="Permalink to &quot;架构&quot;">​</a></h2><p>为了实现功能的按需引入与可扩展性，整体采用插件化架构</p><p><img src="'+p+'" alt="插件化"></p><p>如上图，不同端继承自 Core，每个端各自有多种功能的插件，根据需要引入即可</p><p>为了能统一工作流，降低项目基建成本，提高团队协作性；项目采用目前主流的 <code>monorepo</code> 方式进行代码管理，即把多个 packages 放在同一仓库中，插件也将作为独立的子包放在 packages 下，统一编译、调试、发布</p><p><img src="'+i+'" alt="monorepo"></p><h2 id="数据流" tabindex="-1">数据流 <a class="header-anchor" href="#数据流" aria-label="Permalink to &quot;数据流&quot;">​</a></h2><p>这里我实现了两种模式的服务</p><h3 id="单服务" tabindex="-1">单服务 <a class="header-anchor" href="#单服务" aria-label="Permalink to &quot;单服务&quot;">​</a></h3><p>该模式下日志的上报、写入，与监控后台日志的读取在同一 node 服务中，如下图</p><p>node 服务既负责接收日志，也负责读写数据库</p><p><img src="'+a+'" alt="node server"></p><h3 id="多服务" tabindex="-1">多服务 <a class="header-anchor" href="#多服务" aria-label="Permalink to &quot;多服务&quot;">​</a></h3><p>该模式拆分了“消费服务”与“生产服务”，同时使用了 RabbitMQ 达到削峰填谷的效果，如下图所示</p><p><img src="'+e+'" alt="server with rabbitMQ"></p><p>producer 即生产者，负责接收客户端上报的日志，并推入消息队列。</p><p>consumer 也即消费者，从消息队列中读取消息，拼接日志信息，写入数据库中；同时处理监控后台发来的请求，从数据库中读取相应信息，处理后返回给监控后台。</p>',18),_=[c];function d(l,h,m,u,f,b){return t(),o("div",null,_)}const x=r(n,[["render",d]]);export{q as __pageData,x as default};
